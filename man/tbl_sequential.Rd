% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gt.R
\name{tbl_sequential}
\alias{tbl_sequential}
\title{Make a table of sequentially fit models using \code{gt}}
\usage{
tbl_sequential(
  data,
  terms,
  models,
  model_label = NULL,
  model_notes = NULL,
  by = NULL,
  values = c("estimate", "conf.low", "conf.high"),
  pattern = "{1} ({2}, {3})",
  statistic = NULL,
  style = fill ~ list(color = "lightgreen"),
  decimals = 2,
  ...
)
}
\arguments{
\item{data}{A data table with columns that are similar to that from
\code{\link[broom:reexports]{broom::tidy()}}, along with an naming variable that identifies which model
the data is coming from. The default options presume that the data was
generated from \code{\link[broom:reexports]{broom::tidy()}} with confidence intervals included.}

\item{terms}{A \emph{formula ~ list} where the left-hand side indicates the column
in \strong{data} and right-hand side indicates which variables are of interest,
along with their potential label (thus a named list).

For example, \code{term ~ list(x = "primary")} would select the column named
"term" and it would label variable "x" with the description "primary" for
display in the column headings.

If instead, no name is given, such as \code{term ~ list("x")} it is presumed
that the variables will go by their original name from the table.}

\item{models}{A \emph{formula ~ list} pattern where the left-hand side indicates
the column in \strong{data} that contains the model identifiers, and the
right-hand side indicates which models should be used. If it is given as a
named list, then the models will be relabeled when displayed.

For example, \code{model_id ~ list(1, 3, 5)} would select the models labelled as
"1", "3", and "5". These would be re-sequenced as "1", "2", "3" for
simplicity.

If a named list is given, such as \code{model_id ~ list(m = "Unadjusted")}, they
will not be re-sequenced. If the model identifier is numeric, then it must
be treated as a character when placed in a named list if it is being
labeled, such as \code{model_id ~ list("1" = "Unadjusted")}.}

\item{model_label}{Character vector for naming the models. If the models are
not labeled as above, then this optional argument can be used to prefix the
sequence of variables. The default is NULL, which retains the original
model identifiers instead.}

\item{model_notes}{This is an unnamed \code{list} object that allows for simple
labeling of the how the sequential models are built. This list should be
\code{length(models) + 1}. The first term is required to be the outcome
variable. Subsequent list positions represent the additional terms that
were included for sequential adjustment. There should be an item for each
position selected by the \strong{models} argument.

For example:

\code{model_notes = list("outcome", "exposure", "x1", c("x2", "x3"))}

\eqn{Model 1 = outcome ~ exposure}

\eqn{Model 2 = outcome ~ Model 1 + x1}

\eqn{Model 3 = outcome ~ Model 2 + x2 + x3}}

\item{by}{This can either be a \emph{string} or a \emph{formula ~ list} pattern.
Defaults to NULL. If present, presumes a grouping variable or level of
analyses were present. If a string is passed, then each group is given the
label that represents the value of the level by default. If a \emph{formula} is
passed, then the left-hand side represents the column that is the grouping
variable, and the right-hand side is a named list that indicates what
should be relabeled.

For example, \code{level ~ list("0" = "Empty", "1" = "Full")} would relabel the
groups with "Empty" and "Full" for the corresponding levels.}

\item{values}{The numeric columns that contain the variables that should be
displayed, such as \code{values = c("estimate", "conf.low", "conf.high")},
which will be merged together in format chosen by the \strong{pattern}
argument. The first element is the primary variable to be displayed.}

\item{pattern}{A string that uses \code{\link[glue:glue]{glue::glue()}} to describe how the display
columns should be arranged. With \code{pattern = "{1} ({2}, {3})"}, numbers
represent the corresponding position in the vector given to the \strong{pattern}
argument (e.g. "{1}" represents "estimate").}

\item{statistic}{A \emph{formula} object where the left-hand side indicates the
statistic column of interest, and the right-hand side is the cut-off value
for that parameter. For example, \code{statistic = p.value ~ 0.05} would select
the "p.value" column and identify which cells had value under 0.05.
Defaults to NULL.}

\item{style}{If a \strong{statistic} was chosen, then specific options can be
passed to help emphasize those particular cells. This is a \emph{formula ~ list}
object where the left-hand side indicates the type of style to choose, and
the right-hand side indicates the implementation. These are based on the
[\code{\link[gt:tab_style]{gt::tab_style()}}] function.

Left-hand side should be one of c(fill, text, borders), which correspond to
to \code{cell_fill()}, \code{cell_text()}, and \code{cell_borders()}. The right-hand side
is a named list such as \code{list(color = lightgreen)}, and accepts options
described by the \code{gt} package. There is no validation for the options at
this time, so see documentation the \code{gt} package for details.}

\item{decimals}{The number of decimals to be used for displaying output.
Defaults to 2 decimal places.}

\item{...}{For passing additional arguments}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

This function is a wrapper for the \code{gt} package for quickly and easily making
model tables. It is built for sequentially adjusted models that have been
created from the \code{\link[dagger:extract_models]{dagger::extract_models()}} function, which is primarily uses
the \code{\link[broom:reexports]{broom::tidy()}} function to help describe model fits.
}
\seealso{
Other visualizers: 
\code{\link{theme_gt_compact}()}
}
\concept{visualizers}
